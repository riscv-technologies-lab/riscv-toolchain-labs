<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to cross-toolchains for RISC-V</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Instructions</li><li class="chapter-item expanded "><a href="01-intro-to-cross/00-title-page.html"><strong aria-hidden="true">1.</strong> Introduction to cross compilation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-intro-to-cross/01-hello-riscv.html"><strong aria-hidden="true">1.1.</strong> Hello World!</a></li></ol></li><li class="chapter-item expanded "><a href="02-toolchain/02-toolchain.html"><strong aria-hidden="true">2.</strong> Toolchain</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02-toolchain/02-live-coding.html"><strong aria-hidden="true">2.1.</strong> Live Coding</a></li></ol></li><li class="chapter-item expanded "><a href="03-linkers/03-linkers.html"><strong aria-hidden="true">3.</strong> Linkers</a></li><li class="chapter-item expanded "><a href="04-linux-intro/00-linux-intro.html"><strong aria-hidden="true">4.</strong> Linux intro</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-linux-intro/01-preparations.html"><strong aria-hidden="true">4.1.</strong> Prerequisites</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to cross-toolchains for RISC-V</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/riscv-technologies-lab/riscv-toolchain-labs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-cross-compilation"><a class="header" href="#introduction-to-cross-compilation">Introduction to cross-compilation</a></h1>
<p>This lesson shall serve as an introduction to cross-compilation and user mode
emulation. We assume the reader has some previous knowledge of C/C++ languages
and is familiar with linux and command line. It's recommended to review the following
resources before diving into practical aspects:</p>
<ul>
<li><a href="http://landley.net/writing/docs/cross-compiling.html">Introduction to cross-compiling for Linux</a></li>
<li><a href="https://youtu.be/335ylTUlyng?si=VbfusqEvtgz4_iNL">Toolchain &amp; Pony 🦄</a></li>
</ul>
<p>In this lesson you will learn how to build a simple C program targeting with cross-gcc toolchain targeting riscv64 arch
and run it on your computer via <a href="https://www.qemu.org/docs/master/user/main.html">qemu-user</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="compiling-our-first-hello-world-program"><a class="header" href="#compiling-our-first-hello-world-program">Compiling our first hello world program</a></h2>
<p>First clone this <a href="https://github.com/riscv-technologies-lab/riscv-toolchain-labs">repo</a> and install the cross toolchain for riscv64.
This depends on your distribution. We assume a debian based operating system, but feel free to use any distro you want.</p>
<pre><code class="language-bash">sudo apt install build-essential gcc-riscv64-linux-gnu qemu-user
</code></pre>
<p>Clone and navigate to the <code>labs/01-hello-riscv</code> directory:</p>
<pre><code class="language-bash">git clone https://github.com/riscv-technologies-lab/riscv-toolchain-labs.git cross-labs
cd cross-labs/labs/01-hello-riscv
</code></pre>
<p>Let's compile a simple hello world program natively. Take a look at
the <code>Makefile</code> that we've prepared.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() { printf(&quot;Hello, RISC-V!\n&quot;); }
</code></pre>
<pre><code class="language-bash">make run # compile the program natively
# gcc hello.c -o build/hello.elf
# build/hello.elf
# Hello, RISC-V!
</code></pre>
<p>Let's take a look at the generated executable with <code>file</code> command:</p>
<pre><code class="language-bash">make show # run: file build/hello.elf
# gcc hello.c -o build/hello.elf
# file build/hello.elf
# build/hello.elf: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=52deb0fc601275b33ab8a638447f4bf2dcc1bb4a, for GNU/Linux 3.2.0, not stripped
</code></pre>
<p>We can dig deeper with <code>ldd</code> <a href="https://man7.org/linux/man-pages/man1/ldd.1.html">command</a>.</p>
<pre><code class="language-bash">ldd build/hello.elf
# linux-vdso.so.1 (0x00007fff042e9000)
# libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f058ff59000)
# /lib64/ld-linux-x86-64.so.2 (0x00007f0590169000)
</code></pre>
<p>What is <a href="https://man7.org/linux/man-pages/man7/vdso.7.html">vDSO</a>?
Now run <code>readelf</code> utility on the compiled binary and take explore the output by yourself.
What happens if you compile with <code>CCFLAGS=-static</code> and run <code>readelf</code> again? Why is the output bigger?</p>
<h2 id="running-under-qemu-usermode-emulation"><a class="header" href="#running-under-qemu-usermode-emulation">Running under qemu usermode emulation</a></h2>
<p>Run <code>hello.elf</code> with native <a href="https://www.qemu.org/docs/master/user/main.html">usermode qemu</a>.
There's a make target to do that:</p>
<pre><code>make run-qemu
</code></pre>
<h2 id="compile-and-run-for-riscv64-arch"><a class="header" href="#compile-and-run-for-riscv64-arch">Compile and run for riscv64 arch</a></h2>
<p>Repeat the previous steps but with <code>riscv64</code> toolchain. You can set make variables
from command line, if they are defined with <code>?=</code>. Take a look <a href="https://ftp.gnu.org/old-gnu/Manuals/make-3.79.1/html_chapter/make_6.html#SEC58">here</a>.
Set the compiler to <code>riscv64-linux-gnu-gcc</code> and qemu executable to <code>qemu-riscv64</code>.
On ubuntu-23.04 <code>make run-qemu</code> fails with <code>Could not open '/lib/ld-linux-riscv64-lp64d.so.1'</code>.
In case you encounter such an error run you can either compile with <code>-static</code> flag or create
symlink <code>riscv64-linux-gnu-ld</code> with <code>ln -s</code> to the correct location. See the <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc/issues/114">issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="downloading-toolchain-and-compiling-your-own"><a class="header" href="#downloading-toolchain-and-compiling-your-own">Downloading toolchain and compiling your own</a></h2>
<p>In this lab you will take a look at GNU and LLVM toolchains, where to find them and how to setup them
on your system.
You will also get acquainted with docker and its applications, we will use docker image with
prebuilt sc-dt package, which includes GNU ang LLVM toolchains.</p>
<h3 id="docker-usage"><a class="header" href="#docker-usage">Docker usage</a></h3>
<p>Navigate to <a href="https://github.com/riscv-technologies-lab/testgen-lectures/tree/main/tutorials">docker tutorials</a>
in order to setup your docker.</p>
<p>Pull image and run container:</p>
<pre><code class="language-bash">docker run \
    --interactive \
    --tty \
    --detach \
    --env &quot;TERM=xterm-256color&quot; \
    --mount type=bind,source=&quot;$(pwd)&quot;,target=&quot;$(pwd)&quot; \
    --name cpp \
    --ulimit nofile=1024:1024 \
    ghcr.io/riscv-technologies-lab/rv_tools_image:1.0.1
</code></pre>
<p>Wait for the image to pull, then you will enter the container.</p>
<h3 id="glancing-at-your-first-toolchain"><a class="header" href="#glancing-at-your-first-toolchain">Glancing at your first toolchain</a></h3>
<p>The docker container has both GNU and LLVM toolchains in it. They are both installed in <code>/opt/sc-dt/</code> directory.</p>
<p>Here is the GNU toolchain: <code>/opt/sc-dt/riscv-gcc</code>
And here is the LLVM toolchain: <code>/opt/sc-dt/llvm/</code></p>
<p>You will also see <code>env.sh</code> script in <code>/opt/sc-dt/</code> directory. This script exports environment variables to
your environment. Try running following:</p>
<pre><code class="language-bash">source /opt/sc-dt/env.sh
</code></pre>
<p><em>Task</em>: what changed after running the script? Take a look at your environmental variables before and after running the script. Compare and provide description. What does <code>source</code> command do?</p>
<p>Now you can access toolchains from <code>sc-dt</code> with either absolute typing: <code>/opt/sc-dt/riscv-gcc/</code> or
using environmental variable: <code>$SC_GCC_PATH/</code></p>
<p>Navigate to <code>labs/02-toolchain/</code> directory.
Take a look at <code>hello.c</code>, this is the same program you tried at the previous lab, and the same <code>Makefile</code>.
We will use those with our new toolchain.</p>
<p>As you can see in the <code>Makefile</code>, there are a few variables at the top:</p>
<pre><code class="language-makefile">CC ?= gcc
QEMU_USER ?= qemu-x86_64
CCFLAGS ?= 
</code></pre>
<p>It is a very common and a good practice to set such variables and use them throughout the Makefile.
The reason is, it is much more readable, and they can be redefined with some new value. For instance,
we can change the compiler, change the flags while using the same Makefile for our program.</p>
<p>Let's change the default compile in our <code>Makefile</code> to the one from sc-dt GNU toolchain:</p>
<p><em>Note</em>: how do variables work in shell? Try accomplishing the same goal using <code>export</code> and explain the difference.</p>
<pre><code class="language-bash">CC=/opt/sc-dt/riscv-gcc/bin/riscv64-unknown-linux-gnu-gcc QEMU_USER=/opt/sc-dt/tools/bin/qemu-riscv64 make build
</code></pre>
<p>Remember, if you encounter error like the following:</p>
<pre><code>qemu-riscv64: Could not open '/lib/ld-linux-riscv64-lp64d.so.1': No such file or directory
</code></pre>
<p>Pass additionally <code>CFLAGS=-static</code> along with <code>CC</code> and <code>QEMU_USER</code></p>
<p>We redefined the <code>CC</code>, <code>CFLAGS</code> and  <code>QEMU_USER</code> variables to different value and ran build command. We see now that it ran successfully using specified compiler:</p>
<pre><code class="language-bash">/opt/sc-dt/riscv-gcc/bin/riscv64-unknown-linux-gnu-gcc  hello.c -o build/hello.elf
</code></pre>
<p>Now run on QEMU:</p>
<pre><code>CC=/opt/sc-dt/riscv-gcc/bin/riscv64-unknown-linux-gnu-gcc QEMU_USER=/opt/sc-dt/tools/bin/qemu-riscv64 CFLAGS=-static make run-qemu
</code></pre>
<h3 id="connecting-with-debugger"><a class="header" href="#connecting-with-debugger">Connecting with debugger</a></h3>
<p>It's time for us to use the debugger. We'll stick with GDB from sc-dt for now.</p>
<p>The debugger is located at <code>$SC_GCC_PATH/bin/riscv64-unknown-linux-gnu-gdb</code></p>
<p>First, add <code>-g</code> to <code>CFLAGS</code> variable. This adds debug symbols to final binary.
They significantly affect binary size, but without them we cannot to proper debugging.
<em>Task</em>: compare binary size with and without debug symbols enabled. Use <code>objdump</code> tool from
toolchain to find those debug symbols added by compiler.</p>
<p>Now connect to qemu, make it wait for gdb connection:</p>
<p><code>/opt/sc-dt/tools/bin/qemu-riscv64 -g 1234 build/hello.elf</code></p>
<p>Open another terminal, and use gdb to connect to it:</p>
<p><code>/opt/sc-dt/riscv-gcc/bin/riscv64-unknown-linux-gnu-gdb</code></p>
<p>Inside gdb, connect to qemu by port 1234. Set breakpoint on main and run application:</p>
<pre><code>target remote localhost:1234 # note: you can use &quot;tar rem :1234&quot;
b main
continue
</code></pre>
<p>Now you should see following:</p>
<pre><code class="language-shell">(gdb) tar rem :1234
Remote debugging using :1234
Reading /home/stanislav/mipt/masters/riscv-toolchain-labs/labs/02-toolchain/fibb.elf from remote target...
warning: File transfers from remote targets can be slow. Use &quot;set sysroot&quot; to access files locally instead.
Reading /home/stanislav/mipt/masters/riscv-toolchain-labs/labs/02-toolchain/fibb.elf from remote target...
Reading symbols from target:/home/stanislav/mipt/masters/riscv-toolchain-labs/labs/02-toolchain/fibb.elf...
0x000000000001054c in _start ()
(gdb)
</code></pre>
<h3 id="major-tasks"><a class="header" href="#major-tasks">Major tasks</a></h3>
<h4 id="porting-application-to-risc-v"><a class="header" href="#porting-application-to-risc-v">Porting application to RISC-V</a></h4>
<p>In this task, you must choose an application you will be porting (for instance, your application for quadratic equation solution) and port it to RISC-V:</p>
<ul>
<li>Create a Makefile for your application. Makefile should have build and run on qemu targets, you must be able to change compiler and simulator (and also compilation flags)</li>
<li>For convenience, add Makefile target that runs on qemu / runs gdb / builds application using docker instead console:</li>
</ul>
<pre><code class="language-shell">make build-docker # This will enter docker container and build application inside it
</code></pre>
<ul>
<li>Build your app, verify that it runs on a simulator</li>
<li>Build with both GNU and LLVM toolchain. Try different optimization levels, compare assemblers. Compare them and list some differences.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="downloading-toolchain-and-compiling-your-own-1"><a class="header" href="#downloading-toolchain-and-compiling-your-own-1">Downloading toolchain and compiling your own</a></h2>
<ul>
<li>Show docker usage with riscv-tools image</li>
<li>Briefly show necessary tools from toolchain and how to work with them</li>
<li>Demonstrate building risc-v toolchain from sources</li>
<li>Demonstrate compiler output for sample app (GCC and CLANG)</li>
<li>Create sample app with Makefile and try compiling using custom toolchain, sc-dt toolchain
and thead toolchain</li>
<li>Run on qemu, connect with debugger and test out</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="learning-linkers"><a class="header" href="#learning-linkers">Learning linkers</a></h2>
<p>In this lab, you will gain hands-on experience with relocations, how linkers resolve them,
as well as get some knowledge about static / dynamic linking. Navigate to <code>labs/03-linkers</code> to see the examples we've prepared for you.</p>
<h3 id="definitions-and-declarations"><a class="header" href="#definitions-and-declarations">Definitions and declarations</a></h3>
<p><em>Declaration</em> in C introduces identifier and describes its type, whether it is a type, object or a function.</p>
<p><em>Definition</em> in C instantiates / implement the identifier. It is what linker needs in order to make references to those entities.</p>
<p>Take a look at following declarations:</p>
<pre><code class="language-c">extern int bar;
extern int mul(int a, int b);
double sum(int a, double b);
struct foo;
</code></pre>
<p>Take a look at <code>main.c</code> and <code>fact.c</code> provided.</p>
<pre><code class="language-c">int main() {
  unsigned f = fact(5);
  printf(&quot;%u\n&quot;, f);
  return 0;
}
</code></pre>
<pre><code class="language-c">unsigned fact(unsigned x) {
  if (x &lt; 2)
    return 1;

  return x * fact(x - 1);
}
</code></pre>
<p>First, let's from here use only <code>RISC-V toolchain</code>:</p>
<pre><code class="language-shell">source /opt/sc-dt/env.sh # NOTE: if you are using something other than bash, this might not work. If so, try the old fashioned path export
export CC=/opt/sc-dt/riscv-gcc/bin/
export PATH=${PATH}:/opt/sc-dt/riscv-gcc/bin
export PATH=${PATH}:/opt/sc-dt/tools/bin # For QEMU
</code></pre>
<p><code>main</code> here does not know that <code>fact</code> function exists. If we try to compile main to the executable <code>make exec</code>, we will get following error:</p>
<pre><code class="language-shell">/opt/sc-dt/riscv-gcc/bin/../lib/gcc/riscv64-unknown-linux-gnu/12.2.1/../../../../riscv64-unknown-linux-gnu/bin/ld: /tmp/ccqIh9oC.o: in function `main':
main.c:(.text+0xa): undefined reference to `fact'
collect2: error: ld returned 1 exit status
</code></pre>
<p>Linker failed to find definition for <em>the definition</em> for <code>fact</code> function.</p>
<h4 id="task-31"><a class="header" href="#task-31">Task 3.1</a></h4>
<p>Use <code>readelf</code> and <code>file</code> utilities to investigate  <code>main.o</code> file and its contents and answer following questions:</p>
<p>Format for the following assignment: answer the questions in markdown file.</p>
<ul>
<li>What is the type of the file?</li>
<li>How many sections are there?</li>
<li>List all entries in the same format <code>readelf</code>
prints it</li>
<li>Why does entries for <code>print</code> and <code>fact</code> functions have <code>NOTYPE</code> type?</li>
<li>Modify the following example so executable is produced correctly.</li>
</ul>
<h3 id="relocations"><a class="header" href="#relocations">Relocations</a></h3>
<p>Let's take a look at <code>objdump</code> output:</p>
<pre><code>riscv64-unknown-linux-gnu-objdump -d main.o
</code></pre>
<p>We will notice that we have address of factorial function is all zeroes:</p>
<pre><code class="language-shell">    e:	000080e7          	jalr	ra # a &lt;main+0xa&gt;
</code></pre>
<p>Now compile both files and link into a single executable and look at the call address:</p>
<pre><code class="language-shell">make bin
</code></pre>
<pre><code class="language-shell">riscv64-unknown-linux-gnu-objdump -d fact | grep fact
</code></pre>
<p>You will see that fact now has been assigned an address and <code>main</code> nows how to call it:</p>
<pre><code class="language-shell">fact:     file format elf64-littleriscv
   105fc:	028000ef          	jal	ra,10624 &lt;fact&gt;
0000000000010624 &lt;fact&gt;:
   1063c:	00e7e463          	bltu	a5,a4,10644 &lt;fact+0x20&gt;
   10642:	a839                	j	10660 &lt;fact+0x3c&gt;
   1064e:	fd7ff0ef          	jal	ra,10624 &lt;fact&gt;

</code></pre>
<p>The linker managed to find <code>fact</code> function and insert the correct address for it. It used <em>relocations</em> to do it.</p>
<pre><code class="language-shell">riscv64-unknown-linux-gnu-readelf -r main.o
</code></pre>
<p>Possible output:</p>
<pre><code class="language-shell">Relocation section '.rela.text' at offset 0x268 contains 8 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000a  000c00000012 R_RISCV_CALL      0000000000000000 fact + 0
00000000000a  000000000033 R_RISCV_RELAX                        0
00000000001e  00080000001a R_RISCV_HI20      0000000000000000 .LC0 + 0
00000000001e  000000000033 R_RISCV_RELAX                        0
000000000022  00080000001b R_RISCV_LO12_I    0000000000000000 .LC0 + 0
000000000022  000000000033 R_RISCV_RELAX                        0
000000000026  000d00000012 R_RISCV_CALL      0000000000000000 printf + 0
000000000026  000000000033 R_RISCV_RELAX                        0
</code></pre>
<p>From the output we see that both <code>fact</code> and <code>printf</code> names calls have their relocations. These relocations are provided by compiler to asssist linker in resolving symbols.</p>
<h3 id="static-libraries"><a class="header" href="#static-libraries">Static libraries</a></h3>
<p>The following command:</p>
<pre><code>riscv64-unknown-linux-gnu-gcc main.c fact.c  -o fact
</code></pre>
<p>compiles program to executable. But no linker here is invoked? Or is it?</p>
<p>Pass <code>--verbose</code> flag to dive deeper into what gcc actually calls under the hood.</p>
<p>Find <code>collect2</code> call line:</p>
<pre><code>/opt/sc-dt/riscv-gcc/bin/../libexec/gcc/riscv64-unknown-linux-gnu/12.2.1/collect2 -plugin /opt/sc-dt/riscv-gcc/bin/../libexec/gcc/riscv64-unknown-linux-gnu/12.2.1/liblto_plugin.so -plugin-opt=/opt/sc-dt/riscv-gcc/bin/../libexec/gcc/riscv64-unknown-linux-gnu/12.2.1/lto-wrapper -plugin-opt=-fresolution=/tmp/cc1yCRZY.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/opt/sc-dt/riscv-gcc/bin/../sysroot --eh-frame-hdr -melf64lriscv -dynamic-linker /lib/ld-linux-riscv64-lp64d.so.1 -o fact /opt/sc-dt/riscv-gcc/bin/../sysroot/usr/lib64/lp64d/crt1.o /opt/sc-dt/riscv-gcc/bin/../lib/gcc/riscv64-unknown-linux-gnu/12.2.1/crti.o /opt/sc-dt/riscv-gcc/bin/../lib/gcc/riscv64-unknown-linux-gnu/12.2.1/crtbegin.o -L/opt/sc-dt/riscv-gcc/bin/../lib/gcc/riscv64-unknown-linux-gnu/12.2.1 -L/opt/sc-dt/riscv-gcc/bin/../lib/gcc -L/opt/sc-dt/riscv-gcc/bin/../lib/gcc/riscv64-unknown-linux-gnu/12.2.1/../../../../riscv64-unknown-linux-gnu/lib/../lib64/lp64d -L/opt/sc-dt/riscv-gcc/bin/../sysroot/lib/../lib64/lp64d -L/opt/sc-dt/riscv-gcc/bin/../lib/gcc/riscv64-unknown-linux-gnu/12.2.1/../../../../riscv64-unknown-linux-gnu/lib -L/opt/sc-dt/riscv-gcc/bin/../sysroot/lib64/lp64d -L/opt/sc-dt/riscv-gcc/bin/../sysroot/usr/lib64/lp64d -L/opt/sc-dt/riscv-gcc/bin/../sysroot/lib /tmp/ccOEmH9J.o /tmp/cc6v5KHP.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /opt/sc-dt/riscv-gcc/bin/../lib/gcc/riscv64-unknown-linux-gnu/12.2.1/crtend.o /opt/sc-dt/riscv-gcc/bin/../lib/gcc/riscv64-unknown-linux-gnu/12.2.1/crtn.o

</code></pre>
<p><code>collect2</code> is the actual command called in the process of linking.</p>
<p>Try examining every argument and describe what it is responsible for.</p>
<p>Mostly all of the arguments are paths to libraries.</p>
<p>Static libraries are embedded to applications code directly.</p>
<p>Let's create or own little static library:</p>
<pre><code>riscv64-unknown-linux-gnu-ar cr libfact.o fact.o
</code></pre>
<p>Use <code>nm</code> utility to get the list of symbols available in the archive:</p>
<pre><code>riscv64-unknown-linux-gnu-nm libfact.o
</code></pre>
<pre><code>fact.o:
0000000000010294 r __abi_tag
0000000000012040 B __BSS_END__
0000000000012038 B __bss_start
0000000000012038 b completed.0
0000000000012000 D __DATA_BEGIN__
0000000000012000 D __data_start
0000000000012000 W data_start
000000000001048a t deregister_tm_clones
00000000000104d0 t __do_global_dtors_aux
0000000000011e18 d __do_global_dtors_aux_fini_array_entry
0000000000012030 D __dso_handle
0000000000011e20 d _DYNAMIC
0000000000012038 D _edata
0000000000012040 B _end
0000000000010524 T fact
00000000000104f2 t frame_dummy
0000000000011e10 d __frame_dummy_init_array_entry
0000000000010608 r __FRAME_END__
0000000000012020 d _GLOBAL_OFFSET_TABLE_
0000000000012800 A __global_pointer$
00000000000105cc r __GNU_EH_FRAME_HDR
0000000000011e18 d __init_array_end
0000000000011e10 d __init_array_start
0000000000012028 D _IO_stdin_used
00000000000105c2 T __libc_csu_fini
000000000001056a T __libc_csu_init
                 U __libc_start_main@GLIBC_2.27
000000000001047e t load_gp
00000000000104f4 T main
                 U printf@GLIBC_2.27
0000000000010410 t _PROCEDURE_LINKAGE_TABLE_
00000000000104a8 t register_tm_clones
0000000000012028 D __SDATA_BEGIN__
0000000000010450 T _start
0000000000012000 D __TMC_END__

</code></pre>
<p>To link with your static or dynamic library, pass <code>-llib</code>  argument to compilation flags. <code>lib</code> is the name of library.</p>
<p>Note that linking directly with <code>ld</code> is strongly discouraged, instead, use <code>gcc</code> or <code>clang</code> driver and pass additional options to linker if needed.</p>
<h4 id="task-32"><a class="header" href="#task-32">Task 3.2</a></h4>
<ul>
<li>Create a separare directory with files for your static library</li>
<li>Write Makefile target which creates static library</li>
<li>Use <code>nm</code> to find out what</li>
<li>Write Makefile target which links</li>
<li>Create your own static library for RISC-V. It would be even better if application was useful, for instance, a custom C logging library.</li>
</ul>
<h3 id="dynamic-linking"><a class="header" href="#dynamic-linking">Dynamic linking</a></h3>
<p>Static linking is portable, because all library code is embedded in the application and no platform support required. But this makes application's code size increase dramatically.</p>
<p>The solution to this problem is <strong>dynamic libraries</strong></p>
<p>Let's create our little dynamic library and link our application against it:</p>
<pre><code class="language-shell">CFLAGS=-fPIC make fact
riscv64-unknown-linux-gnu-gcc -shared fact.o -o libfact.so
</code></pre>
<pre><code class="language-shell">$ file libfact.so
libfact.so: ELF 64-bit LSB shared object, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, not stripped

</code></pre>
<p>Now link your library against <code>libfact.so</code>:</p>
<pre><code>riscv64-unknown-linux-gnu-gcc main.o -o fact -lfact
/opt/sc-dt/riscv-gcc/bin/../lib/gcc/riscv64-unknown-linux-gnu/12.2.1/../../../../riscv64-unknown-linux-gnu/bin/ld: cannot find -lfact: No such file or directory
collect2: error: ld returned 1 exit status
</code></pre>
<p>This happened because our <code>libfact.so</code> is in the current working directory, and linker does not now it should look here.</p>
<p>You can pass paths where linker should search for the libraries with <code>-L</code> option:</p>
<pre><code>riscv64-unknown-linux-gnu-gcc main.o -o fact -L. -lfact
</code></pre>
<p>We told the linker to search for <code>libfact</code> inside our current working directory.</p>
<pre><code>file fact
fact: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, for GNU/Linux 4.15.0, not stripped
</code></pre>
<p>Now let's run it with qemu:</p>
<pre><code>❯ qemu-riscv64 ./fact
./fact: error while loading2 shared libraries: libfact.so: cannot open shared object file: No such file or directory

</code></pre>
<p>What is wrong? We linker the library, didn't we?</p>
<p>The reason is that though we specified where to look for dynamic library, we didn't put that information in the binary.</p>
<p>Let's do it using <code>rpath</code>:</p>
<pre><code>riscv64-unknown-linux-gnu-gcc main.o -o fact -L. -lfact -Wl,-rpath,.
</code></pre>
<p>Now let's try again:</p>
<pre><code>qemu-riscv64  ./fact
./fact: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory
</code></pre>
<p>Now <code>qemu</code> failed to find the C standard library.
We already know how to fix it, let's pass path to <code>glibc</code>:</p>
<pre><code>❯ qemu-riscv64 -L . -L /opt/sc-dt/riscv-gcc/sysroot/ ./fact
120
</code></pre>
<p>Our factorial finally works, and we learned to create dynamic libraries.</p>
<h4 id="task-33"><a class="header" href="#task-33">Task 3.3</a></h4>
<ul>
<li>Create your own little dynamic library. First do it with x86 toolchain, then for RISCV.</li>
<li>Link application with the library and make it run on QEMU and on LicheePi (when available).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="intro-to-linux-and-building-it-for-embedded-systems"><a class="header" href="#intro-to-linux-and-building-it-for-embedded-systems">Intro to Linux and building it for embedded systems</a></h2>
<p>In this lab you will be introduced to basic concepts from Linux based systems.
Basic structure and overview of linux distributions (or distros) will be presented.
You will use <code>qemu-system</code> to boot an existing image for LicheePi4A RISC-V SBC.</p>
<p>First of all, you need to build some of the required tools and download a system image,
which you will need going forth. Following the <a href="04-linux-intro/">preparations</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>The official linux distro for Lichee PI 4A is <a href="https://wiki.sipeed.com/hardware/en/lichee/th1520/lpi4a/7_develop_revyos.html">revyos</a></p>
<h2 id="revyos-image"><a class="header" href="#revyos-image">Revyos image</a></h2>
<p>Download a prebuilt system image from the manufacturer <a href="https://wiki.sipeed.com/hardware/en/lichee/th1520/lpi4a/3_images.html">here</a>.
Here's a direct <a href="https://mega.nz/folder/phoQlBTZ#cZeQ3qZ__pDvP94PT3_bGA/file/k4Bg2BCD">link</a>. Please choose the latest LPI4A_BASIC archive.
Mega has arbitrary restrictions on download size, so LPI4A_FULL is too large and you will get throttled.</p>
<h3 id="build-revyos-qemu"><a class="header" href="#build-revyos-qemu">Build RevyOS QEMU</a></h3>
<p>Vendor has implemented some custom RISC-V spec <em>extensions</em>, so in order to run binaries compiled for their system you will
need a build of custom QEMU.</p>
<h4 id="build-instructions-for-ubuntu-2204"><a class="header" href="#build-instructions-for-ubuntu-2204">Build instructions for <code>ubuntu-22.04</code>.</a></h4>
<p>Install the build-time dependencies.</p>
<pre><code class="language-bash">sudo apt install ninja-build python3-venv build-essential libglib2.0-dev flex bison libpixman-1-dev git fdisk file tsocks
</code></pre>
<p>Fetch the repository and compile it from source.</p>
<pre><code class="language-bash">git clone https://github.com/revyos/qemu revyos-qemu
cd revyos-qemu
git submodule init
git submodule update --recursive
./configure --target-list=riscv64-softmmu,riscv64-linux-user --with-git='tsocks git'
make -j $(nproc)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
